{"version":3,"sources":["../../src/schema/run-sift.js"],"names":["sift","require","_","connectionFromArray","createPageDependency","prepareRegex","Promise","trackInlineObjectsInRootNode","enhancedNodeCache","Map","enhancedNodeCacheId","node","args","internal","contentDigest","id","JSON","stringify","awaitSiftField","fields","k","field","resolve","fieldName","undefined","module","exports","nodes","type","connection","path","clonedArgs","parse","siftifyArgs","object","newObject","each","v","isObject","isArray","Minimatch","mm","makeRe","extractFieldsToSift","prekey","key","preobj","obj","val","forEach","siftArgs","fieldsToSift","filter","includes","push","resolveRecursive","siftFieldsObj","gqFields","all","keys","map","then","innerSift","innerGqConfig","isFunction","getFields","resolvedFields","myNode","cacheKey","has","get","resolvedNode","set","myNodes","index","isEmpty","indexOf","$and","nodeId","result","length","sort","convertedFields","replace","orderBy","order","connectionArray","totalCount"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst { connectionFromArray } = require(`graphql-skip-limit`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst prepareRegex = require(`./prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`./node-tracking`)\n\nconst enhancedNodeCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? `${node.id}${node.internal.contentDigest}${JSON.stringify(args)}`\n    : null\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(node, {}, {}, { fieldName: k })\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n/*\n* Filters a list of nodes using mongodb-like syntax.\n* Returns a single unwrapped element if connection = false.\n*\n*/\nmodule.exports = ({\n  args,\n  nodes,\n  type,\n  connection = false,\n  path = ``,\n}: Object) => {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(args))\n\n  const siftifyArgs = object => {\n    const newObject = {}\n    _.each(object, (v, k) => {\n      if (_.isObject(v) && !_.isArray(v)) {\n        newObject[k] = siftifyArgs(v)\n      } else {\n        // Compile regex first.\n        if (k === `regex`) {\n          newObject[`$regex`] = prepareRegex(v)\n        } else if (k === `glob`) {\n          const Minimatch = require(`minimatch`).Minimatch\n          const mm = new Minimatch(v)\n          newObject[`$regex`] = mm.makeRe()\n        } else {\n          newObject[`$${k}`] = v\n        }\n      }\n    })\n    return newObject\n  }\n\n  // Build an object that excludes the innermost leafs,\n  // this avoids including { eq: x } when resolving fields.\n  function extractFieldsToSift(prekey, key, preobj, obj, val) {\n    if (_.isObject(val) && !_.isArray(val)) {\n      _.forEach((val: any), (v, k) => {\n        preobj[prekey] = obj\n        extractFieldsToSift(key, k, obj, {}, v)\n      })\n    } else {\n      preobj[prekey] = true\n    }\n  }\n\n  const siftArgs = []\n  const fieldsToSift = {}\n  if (clonedArgs.filter) {\n    _.each(clonedArgs.filter, (v, k) => {\n      // Ignore connection and sorting args.\n      if (_.includes([`skip`, `limit`, `sort`], k)) return\n\n      siftArgs.push(siftifyArgs({ [k]: v }))\n      extractFieldsToSift(``, k, {}, fieldsToSift, v)\n    })\n  }\n\n  // Resolves every field used in the node.\n  function resolveRecursive(node, siftFieldsObj, gqFields) {\n    return Promise.all(\n      _.keys(siftFieldsObj).map(k =>\n        Promise.resolve(awaitSiftField(gqFields, node, k))\n          .then(v => {\n            const innerSift = siftFieldsObj[k]\n            const innerGqConfig = gqFields[k]\n            if (\n              _.isObject(innerSift) &&\n              v != null &&\n              innerGqConfig &&\n              innerGqConfig.type &&\n              _.isFunction(innerGqConfig.type.getFields)\n            ) {\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else {\n              return v\n            }\n          })\n          .then(v => [k, v])\n      )\n    ).then(resolvedFields => {\n      const myNode = { ...node }\n      resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n      return myNode\n    })\n  }\n\n  return Promise.all(\n    nodes.map(node => {\n      const cacheKey = enhancedNodeCacheId({ node, args: fieldsToSift })\n      if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n        return Promise.resolve(enhancedNodeCache.get(cacheKey))\n      }\n\n      return resolveRecursive(node, fieldsToSift, type.getFields()).then(\n        resolvedNode => {\n          trackInlineObjectsInRootNode(resolvedNode)\n          if (cacheKey) {\n            enhancedNodeCache.set(cacheKey, resolvedNode)\n          }\n          return resolvedNode\n        }\n      )\n    })\n  ).then(myNodes => {\n    myNodes = myNodes.map(trackInlineObjectsInRootNode)\n    if (!connection) {\n      const index = _.isEmpty(siftArgs)\n        ? 0\n        : sift.indexOf({ $and: siftArgs }, myNodes)\n\n      // If a node is found, create a dependency between the resulting node and\n      // the path.\n      if (index !== -1) {\n        createPageDependency({\n          path,\n          nodeId: myNodes[index].id,\n        })\n\n        return myNodes[index]\n      } else {\n        return null\n      }\n    }\n\n    let result = _.isEmpty(siftArgs)\n      ? myNodes\n      : sift({ $and: siftArgs }, myNodes)\n\n    if (!result || !result.length) return null\n\n    // Sort results.\n    if (clonedArgs.sort) {\n      // create functions that return the item to compare on\n      // uses _.get so nested fields can be retrieved\n      const convertedFields = clonedArgs.sort.fields\n        .map(field => field.replace(/___/g, `.`))\n        .map(field => v => _.get(v, field))\n\n      result = _.orderBy(result, convertedFields, clonedArgs.sort.order)\n    }\n\n    const connectionArray = connectionFromArray(result, args)\n    connectionArray.totalCount = result.length\n    if (result.length > 0 && result[0].internal) {\n      createPageDependency({\n        path,\n        connection: result[0].internal.type,\n      })\n    }\n    return connectionArray\n  })\n}\n"],"file":"run-sift.js"}