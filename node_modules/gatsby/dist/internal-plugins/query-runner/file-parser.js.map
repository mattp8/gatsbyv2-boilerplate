{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["fs","require","crypto","babylon","getGraphQLTag","report","apiRunnerNode","BABYLON_OPTIONS","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","sourceFilename","plugins","getMissingNameErrorMessage","file","stripIndent","parseToAst","filePath","fileStr","ast","transpiled","filename","contents","length","item","tmp","parse","error","undefined","warnForGlobalTag","warn","findGraphQLTags","text","Promise","resolve","reject","then","queries","TaggedTemplateExpression","path","parentPath","node","name","gqlAst","hash","isGlobal","definitions","forEach","def","value","panic","map","d","isStaticQuery","push","ExportNamedDeclaration","state","traverse","innerPath","catch","cache","FileParser","parseFile","readFile","err","indexOf","createHash","update","digest","astDefinitions","kind","parseFiles","files","documents","Map","all","doc","set"],"mappings":"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","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`@babel/parser`)\nconst getGraphQLTag = require(`babel-plugin-remove-graphql-queries`)\n  .getGraphQLTag\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\n\nconst BABYLON_OPTIONS = {\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  allowSuperOutsideMethod: true,\n  sourceType: `unambigious`,\n  sourceFilename: true,\n  plugins: [\n    `jsx`,\n    `flow`,\n    `doExpressions`,\n    `objectRestSpread`,\n    `decorators`,\n    `classProperties`,\n    `classPrivateProperties`,\n    `classPrivateMethods`,\n    `exportDefaultFrom`,\n    `exportNamespaceFrom`,\n    `asyncGenerators`,\n    `functionBind`,\n    `functionSent`,\n    `dynamicImport`,\n    `numericSeparator`,\n    `optionalChaining`,\n    `importMeta`,\n    `bigInt`,\n    `optionalCatchBinding`,\n    `throwExpressions`,\n    `pipelineOperator`,\n    `nullishCoalescingOperator`,\n  ],\n}\n\nconst getMissingNameErrorMessage = file => report.stripIndent`\n  GraphQL definitions must be \"named\".\n  The query with the missing name is in ${file}.\n  To fix the query, add \"query MyQueryName\" to the start of your query.\n  So instead of:\n    {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n\n  Do:\n    query MyQueryName {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n`\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, BABYLON_OPTIONS)\n        ast = tmp\n        break\n      } catch (error) {\n        report.error(error)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      report.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, BABYLON_OPTIONS)\n    } catch (error) {\n      report.error(\n        `There was a problem parsing \"${filePath}\"; any GraphQL ` +\n          `fragments or queries in this file were not processed. \\n` +\n          `This may indicate a syntax error in the code, or it may be a file type ` +\n          `that Gatsby does not know how to parse.`\n      )\n    }\n  }\n\n  return ast\n}\n\nconst warnForGlobalTag = file =>\n  report.warn(\n    `Using the global \\`graphql\\` tag is deprecated, and will not be supported in v3.\\n` +\n      `Import it instead like:  import { graphql } from 'gatsby' in file:\\n` +\n      file\n  )\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise((resolve, reject) => {\n    parseToAst(file, text)\n      .then(ast => {\n        let queries = []\n        if (!ast) {\n          resolve(queries)\n          return\n        }\n\n        // Look for queries in <StaticQuery /> elements.\n        traverse(ast, {\n          TaggedTemplateExpression(path) {\n            if (\n              (`descendant of query`,\n              path?.parentPath?.parentPath?.node?.name?.name !== `query`)\n            ) {\n              return\n            }\n            if (\n              path.parentPath?.parentPath?.parentPath?.node?.name?.name !==\n              `StaticQuery`\n            ) {\n              return\n            }\n            const { ast: gqlAst, text, hash, isGlobal } = getGraphQLTag(path)\n            if (!gqlAst) return\n\n            if (isGlobal) warnForGlobalTag(file)\n\n            gqlAst.definitions.forEach(def => {\n              if (!def.name || !def.name.value) {\n                report.panic(getMissingNameErrorMessage(file))\n              }\n            })\n\n            const definitions = [...gqlAst.definitions].map(d => {\n              d.isStaticQuery = true\n              d.text = text\n              d.hash = hash\n              return d\n            })\n            queries.push(...definitions)\n          },\n        })\n\n        // Look for exported page queries\n        traverse(ast, {\n          ExportNamedDeclaration(path, state) {\n            path.traverse({\n              TaggedTemplateExpression(innerPath) {\n                const { ast: gqlAst, isGlobal } = getGraphQLTag(innerPath)\n                if (!gqlAst) return\n\n                if (isGlobal) warnForGlobalTag(file)\n\n                gqlAst.definitions.forEach(def => {\n                  if (!def.name || !def.name.value) {\n                    report.panic(getMissingNameErrorMessage(file))\n                  }\n                })\n\n                queries.push(...gqlAst.definitions)\n              },\n            })\n          },\n        })\n        resolve(queries)\n      })\n      .catch(reject)\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    let text\n    try {\n      text = await fs.readFile(file, `utf8`)\n    } catch (err) {\n      report.error(`There was a problem reading the file: ${file}`, err)\n      return null\n    }\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      report.error(\n        `There was a problem parsing the GraphQL query in file: ${file}`,\n        err\n      )\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n\n    return Promise.all(\n      files.map(file =>\n        this.parseFile(file).then(doc => {\n          if (!doc) return\n          documents.set(file, doc)\n        })\n      )\n    ).then(() => documents)\n  }\n}\n"],"file":"file-parser.js"}