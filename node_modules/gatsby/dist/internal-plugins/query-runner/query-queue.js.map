{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-queue.js"],"names":["Queue","require","queryRunner","store","emitter","websocketManager","processing","Set","waiting","Map","queue","plObj","callback","state","getState","add","id","components","component","catch","e","console","log","then","result","delete","has","push","get","error","concurrent","merge","oldTask","newTask","cb","priority","job","activePaths","Array","from","values","path","includes","filter","set","on","emit","module","exports"],"mappings":";;AAAA,MAAMA,QAAQC,QAAS,cAAT,CAAd;;AAEA,MAAMC,cAAcD,QAAS,gBAAT,CAApB;;iBAC2BA,QAAS,aAAT,C;MAAnBE,K,YAAAA,K;MAAOC,O,YAAAA,O;;AACf,MAAMC,mBAAmBJ,QAAS,+BAAT,CAAzB;;AAEA,MAAMK,aAAa,IAAIC,GAAJ,EAAnB;AACA,MAAMC,UAAU,IAAIC,GAAJ,EAAhB;AAEA,MAAMC,QAAQ,IAAIV,KAAJ,CACZ,CAACW,KAAD,EAAQC,QAAR,KAAqB;AACnB,QAAMC,QAAQV,MAAMW,QAAN,EAAd;AACAR,aAAWS,GAAX,CAAeJ,MAAMK,EAArB;AAEA,SAAOd,YAAYS,KAAZ,EAAmBE,MAAMI,UAAN,CAAiBN,MAAMO,SAAvB,CAAnB,EACJC,KADI,CACEC,KAAKC,QAAQC,GAAR,CAAa,2BAAb,EAAyCF,CAAzC,CADP,EAEJG,IAFI,CAGHC,UAAU;AACRlB,eAAWmB,MAAX,CAAkBd,MAAMK,EAAxB;;AACA,QAAIR,QAAQkB,GAAR,CAAYf,MAAMK,EAAlB,CAAJ,EAA2B;AACzBN,YAAMiB,IAAN,CAAWnB,QAAQoB,GAAR,CAAYjB,MAAMK,EAAlB,CAAX;AACAR,cAAQiB,MAAR,CAAed,MAAMK,EAArB;AACD;;AACD,WAAOJ,SAAS,IAAT,EAAeY,MAAf,CAAP;AACD,GAVE,EAWHK,SAASjB,SAASiB,KAAT,CAXN,CAAP;AAaD,CAlBW,EAmBZ;AACEC,cAAY,CADd;AAEE;AACAC,SAAO,CAACC,OAAD,EAAUC,OAAV,EAAmBC,EAAnB,KAA0B;AAC/BA,OAAG,IAAH,EAASD,OAAT;AACD,GALH;AAMEE,YAAU,CAACC,GAAD,EAAMF,EAAN,KAAa;AACrB,UAAMG,cAAcC,MAAMC,IAAN,CAAWlC,iBAAiBgC,WAAjB,CAA6BG,MAA7B,EAAX,CAApB;;AACA,QAAIJ,IAAIK,IAAJ,IAAYJ,YAAYK,QAAZ,CAAqBN,IAAIK,IAAzB,CAAhB,EAAgD;AAC9CP,SAAG,IAAH,EAAS,EAAT;AACD,KAFD,MAEO;AACLA,SAAG,IAAH,EAAS,CAAT;AACD;AACF,GAbH;AAcE;AACA;AACA;AACAS,UAAQ,CAACP,GAAD,EAAMF,EAAN,KAAa;AACnB,QAAI5B,WAAWoB,GAAX,CAAeU,IAAIpB,EAAnB,CAAJ,EAA4B;AAC1BR,cAAQoC,GAAR,CAAYR,IAAIpB,EAAhB,EAAoBoB,GAApB;AACAF,SAAI,iBAAJ;AACD,KAHD,MAGO;AACLA,SAAG,IAAH,EAASE,GAAT;AACD;AACF;AAxBH,CAnBY,CAAd;AA+CA1B,MAAMmC,EAAN,CAAU,OAAV,EAAkB,MAAM;AACtBzC,UAAQ0C,IAAR,CAAc,qBAAd;AACD,CAFD;AAIAC,OAAOC,OAAP,GAAiBtC,KAAjB","sourcesContent":["const Queue = require(`better-queue`)\n\nconst queryRunner = require(`./query-runner`)\nconst { store, emitter } = require(`../../redux`)\nconst websocketManager = require(`../../utils/websocket-manager`)\n\nconst processing = new Set()\nconst waiting = new Map()\n\nconst queue = new Queue(\n  (plObj, callback) => {\n    const state = store.getState()\n    processing.add(plObj.id)\n\n    return queryRunner(plObj, state.components[plObj.component])\n      .catch(e => console.log(`Error running queryRunner`, e))\n      .then(\n        result => {\n          processing.delete(plObj.id)\n          if (waiting.has(plObj.id)) {\n            queue.push(waiting.get(plObj.id))\n            waiting.delete(plObj.id)\n          }\n          return callback(null, result)\n        },\n        error => callback(error)\n      )\n  },\n  {\n    concurrent: 4,\n    // Merge duplicate jobs.\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n    priority: (job, cb) => {\n      const activePaths = Array.from(websocketManager.activePaths.values())\n      if (job.path && activePaths.includes(job.path)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    // Filter out new query jobs if that query is already running.  When the\n    // query finshes, it checks the waiting map and pushes another job to\n    // make sure all the user changes are captured.\n    filter: (job, cb) => {\n      if (processing.has(job.id)) {\n        waiting.set(job.id, job)\n        cb(`already running`)\n      } else {\n        cb(null, job)\n      }\n    },\n  }\n)\n\nqueue.on(`drain`, () => {\n  emitter.emit(`QUERY_QUEUE_DRAINED`)\n})\n\nmodule.exports = queue\n"],"file":"query-queue.js"}