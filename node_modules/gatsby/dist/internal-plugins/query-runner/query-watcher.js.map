{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-watcher.js"],"names":["_","require","chokidar","path","store","boundActionCreators","queryCompiler","default","queue","normalize","report","exports","extractQueries","state","getState","pages","components","uniq","map","p","component","staticQueryComponents","queryCompilerPromise","then","queries","queryWillNotRun","forEach","query","includes","replaceComponentQuery","text","componentPath","isStaticQuery","push","replaceStaticQuery","name","id","jsonName","hash","warn","log","stripIndent","process","env","NODE_ENV","watch","program","directory","watcher","add","runQueriesForPageComponent","getPagesForComponent","deleteComponentsDependencies","page","isPage","context","runQueriesForStaticComponent","filter","watchComponent","rootDir","debounceCompile","debounce","noQueryComponents","Object","values","c","has","join","on"],"mappings":"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","sourcesContent":["/** *\n * Jobs of this module\n * - Maintain the list of components in the Redux store. So monitor new components\n *   and add/remove components.\n * - Watch components for query changes and extract these and update the store.\n * - Ensure all page queries are run as part of bootstrap and report back when\n *   this is done\n * - Whenever a query changes, re-run all pages that rely on this query.\n ***/\n\nconst _ = require(`lodash`)\nconst chokidar = require(`chokidar`)\nconst path = require(`path`)\n\nconst { store } = require(`../../redux/`)\nconst { boundActionCreators } = require(`../../redux/actions`)\nconst queryCompiler = require(`./query-compiler`).default\nconst queue = require(`./query-queue`)\nconst normalize = require(`normalize-path`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nexports.extractQueries = () => {\n  const state = store.getState()\n  const pages = [...state.pages]\n  const components = _.uniq(pages.map(p => normalize(p.component)))\n  const staticQueryComponents = []\n  const queryCompilerPromise = queryCompiler().then(queries => {\n    let queryWillNotRun = false\n\n    queries.forEach((query, component) => {\n      if (_.includes(components, component)) {\n        boundActionCreators.replaceComponentQuery({\n          query: query && query.text,\n          componentPath: component,\n        })\n        // Add action / reducer + watch staticquery files\n      } else if (query.isStaticQuery) {\n        staticQueryComponents.push(query.path)\n        boundActionCreators.replaceStaticQuery({\n          name: query.name,\n          componentPath: query.path,\n          id: query.jsonName,\n          jsonName: query.jsonName,\n          query: query.text,\n          hash: query.hash,\n        })\n      } else {\n        report.warn(\n          `The GraphQL query in the non-page component \"${component}\" will not be run.`\n        )\n        queryWillNotRun = true\n      }\n    })\n\n    if (queryWillNotRun) {\n      report.log(report.stripIndent`\n        Queries are only executed for Page components. Instead of a query,\n        co-locate a GraphQL fragment and compose that fragment into the query (or other\n        fragment) of the top-level page that renders this component. For more\n        info on fragments and composition see: http://graphql.org/learn/queries/#fragments\n      `)\n    }\n\n    return\n  })\n\n  // During development start watching files to recompile & run\n  // queries on the fly.\n  if (process.env.NODE_ENV !== `production`) {\n    watch(state.program.directory)\n\n    // Ensure every component is being watched.\n    components.forEach(component => {\n      watcher.add(component)\n    })\n    staticQueryComponents.forEach(component => {\n      watcher.add(component)\n    })\n  }\n\n  return queryCompilerPromise\n}\n\nconst runQueriesForPageComponent = componentPath => {\n  const pages = getPagesForComponent(componentPath)\n  // Remove page data dependencies before re-running queries because\n  // the changing of the query could have changed the data dependencies.\n  // Re-running the queries will add back data dependencies.\n  boundActionCreators.deleteComponentsDependencies(\n    pages.map(p => p.path || p.id)\n  )\n  pages.forEach(page =>\n    queue.push({\n      id: page.path,\n      jsonName: page.jsonName,\n      query: store.getState().components[componentPath].query,\n      isPage: true,\n      context: {\n        ...page,\n        ...page.context,\n      },\n    })\n  )\n}\n\nconst runQueriesForStaticComponent = ({\n  query,\n  hash,\n  jsonName,\n  componentPath,\n}) => {\n  queue.push({\n    id: hash,\n    jsonName,\n    query,\n    context: { path: jsonName },\n  })\n}\n\nconst getPagesForComponent = componentPath => {\n  const state = store.getState()\n  return [...state.pages].filter(p => p.componentPath === componentPath)\n}\n\nlet watcher\nexports.watchComponent = componentPath => {\n  // We don't start watching until mid-way through the bootstrap so ignore\n  // new components being added until then. This doesn't affect anything as\n  // when extractQueries is called from bootstrap, we make sure that all\n  // components are being watched.\n  if (watcher) {\n    watcher.add(componentPath)\n  }\n}\nconst watch = rootDir => {\n  if (watcher) return\n  const debounceCompile = _.debounce(() => {\n    queryCompiler().then(queries => {\n      const components = store.getState().components\n\n      // If a component previously with a query now doesn't â€” update the\n      // store.\n      const noQueryComponents = Object.values(components).filter(\n        c => c.query !== `` && !queries.has(c.componentPath)\n      )\n      noQueryComponents.forEach(({ componentPath }) => {\n        boundActionCreators.replaceComponentQuery({\n          query: ``,\n          componentPath,\n        })\n        runQueriesForPageComponent(componentPath)\n      })\n\n      // Update the store with the new queries and re-run queries that were\n      // changed.\n      queries.forEach(\n        ({ text, path, name, hash, jsonName, isStaticQuery }, id) => {\n          const componentPath = id\n          if (isStaticQuery) {\n            boundActionCreators.replaceStaticQuery({\n              query: text,\n              hash,\n              id: jsonName,\n              jsonName,\n              componentPath: id,\n            })\n            runQueriesForStaticComponent({\n              query: text,\n              hash,\n              jsonName,\n              componentPath: id,\n            })\n          }\n          // Queries can be parsed from non page components\n          // e.g. components with fragments so ignore those.\n          //\n          // If the query has changed, set the new query in the\n          // store and run its queries.\n          if (components[id] && text !== components[id].query) {\n            boundActionCreators.replaceComponentQuery({\n              query: text,\n              componentPath: id,\n            })\n            runQueriesForPageComponent(componentPath)\n          }\n        }\n      )\n    })\n  }, 100)\n\n  watcher = chokidar\n    .watch(path.join(rootDir, `/src/**/*.{js,jsx,ts,tsx}`))\n    .on(`change`, path => {\n      debounceCompile()\n    })\n}\n"],"file":"query-watcher.js"}