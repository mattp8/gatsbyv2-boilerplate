{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","queue","store","emitter","queuedDirtyActions","active","exports","runQueries","uniq","a","payload","id","dirtyIds","findDirtyIds","runQueriesForPathnames","cleanIds","findIdsWithoutDataDependencies","on","action","push","runQueuedActions","seenIdsWithoutDataDependencies","state","getState","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","pages","map","p","path","staticQueryComponents","c","jsonName","pathnames","staticQueries","filter","slice","pageQueries","forEach","staticQueryComponent","get","queryJob","hash","query","componentPath","context","didNotQueueItems","page","find","pl","components","isPage","length","Promise","resolve","actions","uniqDirties","reduce","node","internal","type","compact"],"mappings":"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","sourcesContent":["// @flow\n\nimport type { QueryJob } from \"../query-runner\"\n\n/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\n\nconst queue = require(`./query-queue`)\nconst { store, emitter } = require(`../../redux`)\n\nlet queuedDirtyActions = []\nlet active = false\n\n// Do initial run of graphql queries during bootstrap.\n// Afterwards we listen \"API_RUNNING_QUEUE_EMPTY\" and check\n// for dirty nodes before running queries.\nexports.runQueries = async () => {\n  // Run queued dirty nodes now that we're active.\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  await runQueriesForPathnames(dirtyIds)\n\n  queuedDirtyActions = []\n\n  // Find ids without data dependencies (i.e. no queries have been run for\n  // them before) and run them.\n  const cleanIds = findIdsWithoutDataDependencies()\n\n  // Run these pages\n  await runQueriesForPathnames(cleanIds)\n\n  active = true\n  return\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\nconst runQueuedActions = async () => {\n  if (active) {\n    queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n    await runQueriesForPathnames(findDirtyIds(queuedDirtyActions))\n    queuedDirtyActions = []\n\n    // Find ids without data dependencies (e.g. new pages) and run\n    // their queries.\n    const cleanIds = findIdsWithoutDataDependencies()\n    runQueriesForPathnames(cleanIds)\n  }\n}\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nlet seenIdsWithoutDataDependencies = []\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...state.pages.map(p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.jsonName),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst runQueriesForPathnames = pathnames => {\n  const staticQueries = pathnames.filter(p => p.slice(0, 4) === `sq--`)\n  const pageQueries = pathnames.filter(p => p.slice(0, 4) !== `sq--`)\n  const state = store.getState()\n\n  staticQueries.forEach(id => {\n    const staticQueryComponent = store.getState().staticQueryComponents.get(id)\n    const queryJob: QueryJob = {\n      id: staticQueryComponent.hash,\n      hash: staticQueryComponent.hash,\n      jsonName: staticQueryComponent.jsonName,\n      query: staticQueryComponent.query,\n      componentPath: staticQueryComponent.componentPath,\n      context: { path: staticQueryComponent.jsonName },\n    }\n    queue.push(queryJob)\n  })\n\n  const pages = [...state.pages]\n  let didNotQueueItems = true\n  pageQueries.forEach(id => {\n    const page = pages.find(pl => pl.path === id)\n    if (page) {\n      didNotQueueItems = false\n      queue.push(\n        ({\n          id: page.path,\n          jsonName: page.jsonName,\n          query: store.getState().components[page.componentPath].query,\n          isPage: true,\n          componentPath: page.componentPath,\n          context: {\n            ...page,\n            ...page.context,\n          },\n        }: QueryJob)\n      )\n    }\n  })\n\n  if (didNotQueueItems || !pathnames || pathnames.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    queue.on(`drain`, () => {\n      resolve()\n    })\n  })\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  const uniqDirties = _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find components that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n  return uniqDirties\n}\n"],"file":"page-query-runner.js"}